# Задание на должность backend-developer
Важно не столько безошибочное выполнение, сколько ваш подход к решению задач и качество написания кода. Нас интересует ваше понимание фундаментальных аспектов программирования. Пожалуйста, будьте готовы обсудить ваши методы решения на интервью.
Ваши ответы следует загрузить в репозиторий Git или отправить в виде архива. Все общие задачи могут быть реализованы в одном классе.
## Задачи на общий уровень владения языком
### Условия:
Задачи должны быть решены с помощью кода(PHP, Python, etc).
Важное условие. избегайте использования циклов for / foreach в решениях.
Все задачи основаны на работе с многомерным массивом, где элементы могут иметь повторяющиеся значения id:
```php
$array = [
  	[id => 1, create => "14.04.2023", title => "array1" ...],
	[id => 4, create => "09.02.2023", title => "array4" ...],
  	[id => 2, create => "03.07.2023", title => "array2" ...],
    	[id => 1, create => "22.04.2023", title => "array1" ...],
  	[id => 2, create => "12.12.2023", title => "array4" ...],
  	[id => 3, create => "04.04.2023", title => "array3" ...]
]
```

Создайте PHP скрипт, который выполняет каждую из вышеуказанных задач и выводит результаты. Убедитесь, что ваш код читаем, организован, и соответствует общепринятым стандартам кодирования.










### Задачи:
#### Фильтрация уникальных записей:
Создайте новый массив, который содержит только уникальные записи из исходного массива (без дубликатов id). В результирующем массиве каждый id должен встречаться только один раз.
Ожидаемый результат:
```php
$array = [
	[id => 3, ...],
	[id => 4, ...],
	[id => 2, ...],
	[id => 1, ...],
]
```
#### Сортировка многомерного массива:
Отсортируйте многомерный массив по одному из ключей.
Фильтрация по условиям:
Верните из массива только те элементы, которые удовлетворяют определенному условию (например, имеют заданный id).

#### Изменение cтруктуры массива:
Преобразуйте массив так, чтобы его элементы стали парой ключ-значение, где name становится ключом, а id - значением. 

Ожидаемый результат:
```php
$array = [
	"array4" => 4,
	"array1" => 1,
	"array3" => 3,
	"array2" => 2
]
```



## Задачи на уровень владения SQL
**Дана следующая структура таблицы:**
```sql
CREATE TABLE evaluations (
    respondent_id UUID PRIMARY KEY,   -- ID респондента
    department_id UUID,               -- ID департамента
    name VARCHAR(64),                 -- имя респондента
    bio LONGTEXT,                     -- биография респондента
    gender BOOLEAN,                   -- пол: true - мужчина, false - женщина
    value INTEGER                     -- Оценка
);
```
### Задачи:
#### SQL-запрос без использования JOIN и подзапросов:
Сформулируйте SQL-запрос(без join-ов и подзапросов) для выбора всех департаментов, в которых каждый мужчина поставил оценку строго выше 5. Результатом должен быть список идентификаторов департаментов, соответствующих этому критерию.
#### Оптимизация поиска по биографии:
Предложите метод оптимизации поиска по полю bio для точного совпадения биографии респондента с записью из другой базы данных. Возможно, вам потребуется изменить структуру таблицы или предложить использование специализированных индексов или технологий. Опишите ваше решение и предложите необходимые изменения в структуре таблицы.
Формат ответа:
Для первой задачи предоставьте чистый SQL-запрос.
Для второй задачи предоставьте документацию или описание вашего подхода, включая любые предложения по изменению структуры таблицы и примеры использования новых функций или индексов.
## Архитектурные задачи

### Применение принципа открытости-закрытости:
Имеются два класса: SomeObject, представляющий объект, и SomeObjectsHandler, реализующий обработку этих объектов. Текущая реализация SomeObjectsHandler не соответствует Open-Closed Principle (OCP) из принципов SOLID. Необходимо модифицировать SomeObjectsHandler, чтобы он соответствовал принципу OCP.
**Код:**
```php
class SomeObject {
    protected $name;
    public function __construct(string $name) { }
    public function getObjectName() { }
}
class SomeObjectsHandler {
    public function __construct() { }
    public function handleObjects(array $objects): array {
        $handlers = [];
        foreach ($objects as $object) {
            if ($object->getObjectName() == 'object_1')
                $handlers[] = 'handle_object_1';
            if ($object->getObjectName() == 'object_2')
                $handlers[] = 'handle_object_2';
        }
        return $handlers;
    }
}
$objects = [
    new SomeObject('object_1'),
    new SomeObject('object_2')
];
$soh = new SomeObjectsHandler();
$soh->handleObjects($objects);
```
### Устранение нарушений принципа инверсии зависимостей:
Класс Http зависит от конкретного класса XMLHttpService, что нарушает первый пункт Dependency Inversion Principle (DIP) из принципов SOLID. Необходимо изменить структуру кода так, чтобы устранить эту зависимость.

**Код**
```php
class XMLHttpService extends XMLHTTPRequestService {}
class Http {
    private $service;
    public function __construct(XMLHttpService $xmlHttpService) { }
    public function get(string $url, array $options) {
        $this->service->request($url, 'GET', $options);
    }
    public function post(string $url) {
        $this->service->request($url, 'GET');
    }
}
```
